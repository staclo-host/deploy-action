"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerTarget = void 0;
const ActionConfigStore_1 = require("../../../runOptions/ActionConfigStore");
const CommandsStore_1 = require("../../../runResult/CommandsStore");
const dockerCli_1 = require("./dockerCli");
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const DockerRunResult_1 = require("../runResult/DockerRunResult");
const getContainerArgs_1 = require("./getContainerArgs");
const DockerRunMilieuFactory_1 = require("../runMilieu/DockerRunMilieuFactory");
const DockerRunMilieuComponentsFactory_1 = require("../runMilieu/DockerRunMilieuComponentsFactory");
const ExternalRunnerDir_1 = require("../../../githubServiceFiles/runnerDir/ExternalRunnerDir");
const Duration_1 = require("../../../utils/Duration");
const spawnProc_1 = require("../../../utils/spawnProc");
const DockerOptionsStore_1 = require("./DockerOptionsStore");
const OutputsCommandsCollector_1 = require("../../../stdout/OutputsCommandsCollector");
const WarningsCollector_1 = require("../../../runResult/warnings/WarningsCollector");
class DockerTarget {
    static createFromActionYml(actionYmlPath, dockerOptions) {
        const actionConfig = ActionConfigStore_1.ActionConfigStore.fromFile(actionYmlPath);
        (0, assert_1.default)(actionConfig.data.runs.using.startsWith('docker'), "Passed action config runs.using != docker");
        (0, assert_1.default)(actionConfig.data.runs.image !== undefined, `Action config doesn't have "image" key in "runs" section`);
        const dockerfilePath = actionConfig.data.runs.image;
        const containerArgs = (0, getContainerArgs_1.getContainerArgs)(actionConfig.data);
        return new DockerTarget(actionConfig, actionYmlPath, containerArgs, path_1.default.resolve(path_1.default.dirname(actionYmlPath), dockerfilePath), undefined, DockerOptionsStore_1.DockerOptionsStore.create(dockerOptions));
    }
    static createForDockerfile(dockerfilePath, actionConfigSource, dockerOptions) {
        const actionConfig = ActionConfigStore_1.ActionConfigStore.create(actionConfigSource, false);
        if (actionConfig.data) {
            (0, assert_1.default)(actionConfig.data.runs.using.startsWith('docker'), "Passed action config runs.using != docker");
        }
        return new DockerTarget(actionConfig, typeof actionConfigSource === 'string' ? actionConfigSource : undefined, actionConfig.data ? (0, getContainerArgs_1.getContainerArgs)(actionConfig.data) : [], dockerfilePath, undefined, DockerOptionsStore_1.DockerOptionsStore.create(dockerOptions));
    }
    // noinspection JSUnusedGlobalSymbols
    constructor(actionConfig, actionYmlPath, containerArgs, dockerFilePath, imageId, dockerOptions) {
        this.actionConfig = actionConfig;
        this.actionYmlPath = actionYmlPath;
        this.containerArgs = containerArgs;
        this.dockerFilePath = dockerFilePath;
        this.imageId = imageId;
        this.dockerOptions = dockerOptions;
        this.isAsync = true;
    }
    build(printDebug = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const spawnResult = yield dockerCli_1.DockerCli.build(this.dockerFilePath, printDebug);
            printDebug && spawnProc_1.SpawnProc.debugError(spawnResult);
            if (spawnResult.status === 0) {
                this.imageId = spawnResult.stdout.trim();
            }
            return spawnResult;
        });
    }
    run(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const warningsCollector = new WarningsCollector_1.WarningsCollector(options, this.actionConfig);
            let buildSpawnResult = undefined;
            if (!this.imageId) {
                const buildDuration = Duration_1.Duration.startMeasuring();
                buildSpawnResult = yield this.build(options.outputOptions.data.printRunnerDebug);
                if (buildSpawnResult.error || buildSpawnResult.status !== 0) {
                    return new DockerRunResult_1.DockerRunResult((new CommandsStore_1.CommandsStore()).data, buildSpawnResult.error ||
                        new Error('Docker build error. ' + (buildSpawnResult.stderr || '')), buildSpawnResult.status !== null
                        ? buildSpawnResult.status
                        : undefined, undefined, undefined, buildDuration.measureMs(), options.tempDir
                        ? new ExternalRunnerDir_1.ExternalRunnerDir(options.tempDir)
                        : { existingDirPath: undefined }, options.workspaceDir
                        ? new ExternalRunnerDir_1.ExternalRunnerDir(options.workspaceDir)
                        : { existingDirPath: undefined }, warningsCollector.getAndPrint(), buildSpawnResult, undefined, false);
                }
                (0, assert_1.default)(this.imageId);
            }
            const runMilieu = (new DockerRunMilieuFactory_1.DockerRunMilieuFactory(new DockerRunMilieuComponentsFactory_1.DockerRunMilieuComponentsFactory(options, this.actionConfig))).createMilieu(options.validate());
            const effectiveInputs = this.actionConfig.getDefaultInputs().apply(options.inputs.data);
            const args = this.containerArgs.map(arg => arg instanceof getContainerArgs_1.InputContainerArg
                ? effectiveInputs.data[arg.inputName] || ''
                : arg);
            const commandsCollector = new OutputsCommandsCollector_1.OutputsCommandsCollector(options.outputOptions.data.parseStdoutCommands, options.outputOptions.data.parseStderrCommands);
            const duration = Duration_1.Duration.startMeasuring();
            const spawnResult = yield dockerCli_1.DockerCli.runAndWait({
                imageId: this.imageId,
                env: runMilieu.env,
                volumes: runMilieu.volumes,
                workdir: options.workingDir || DockerTarget.DEFAULT_WORKING_DIR,
                user: this.dockerOptions.getUserForRun(),
                network: this.dockerOptions.data.network,
                args: args,
                timeoutMs: options.timeoutMs,
                printDebug: options.outputOptions.data.printRunnerDebug,
                printStdout: options.outputOptions.data.printStdout,
                stdoutTransform: options.outputOptions.stdoutTransform,
                printStderr: options.outputOptions.data.printStderr,
                stderrTransform: options.outputOptions.stderrTransform,
                onSpawn: child => {
                    if (commandsCollector.stdoutParsingStream) {
                        child.stdout.pipe(commandsCollector.stdoutParsingStream);
                    }
                    if (commandsCollector.stderrParsingStream) {
                        child.stderr.pipe(commandsCollector.stderrParsingStream);
                    }
                }
            });
            const durationMs = duration.measureMs();
            yield commandsCollector.waitUntilStreamsAreClosed();
            try {
                if (spawnResult.stderr && !options.outputOptions.data.printStderr) {
                    spawnProc_1.SpawnProc.debugError(spawnResult);
                }
                else if (spawnResult.error) {
                    spawnProc_1.SpawnProc.debugError(spawnResult);
                }
                const effects = runMilieu.getEffects();
                if (options.fakeFsOptions.data.fakeCommandFiles) {
                    commandsCollector.commandsStore.applyAndMerge(effects.fileCommands);
                }
                warningsCollector.setCommandWarnings(commandsCollector.commandWarnings);
                return new DockerRunResult_1.DockerRunResult(commandsCollector.commandsStore.data, spawnResult.error, spawnResult.status !== null ? spawnResult.status : undefined, spawnResult.stdout, spawnResult.stderr, durationMs, effects.runnerDirs.data.temp, effects.runnerDirs.data.workspace, warningsCollector.getAndPrint(), buildSpawnResult, spawnResult, true);
            }
            finally {
                runMilieu.restore();
            }
        });
    }
    clone() {
        return new DockerTarget(this.actionConfig.clone(), this.actionYmlPath, [...this.containerArgs], this.dockerFilePath, this.imageId, this.dockerOptions.clone());
    }
}
exports.DockerTarget = DockerTarget;
DockerTarget.DEFAULT_WORKING_DIR = '/github/workspace';
//# sourceMappingURL=DockerTarget.js.map