"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerRunMilieuComponentsFactory = void 0;
const RunnerDirsCollection_1 = require("../../../githubServiceFiles/RunnerDirsCollection");
const BaseRunMilieuComponentsFactory_1 = require("../../../runMilieu/BaseRunMilieuComponentsFactory");
const FakeRunnerDir_1 = require("../../../githubServiceFiles/runnerDir/FakeRunnerDir");
const EnvStore_1 = require("../../../runOptions/EnvStore");
const FakeFilesCollection_1 = require("../../../githubServiceFiles/FakeFilesCollection");
const collections_1 = require("../../../utils/collections");
const GithubServiceFileName_1 = require("../../../githubServiceFiles/GithubServiceFileName");
const path_1 = __importDefault(require("path"));
const assert_1 = __importDefault(require("assert"));
class DockerRunMilieuComponentsFactory {
    constructor(options, actionConfig) {
        this.options = options;
        this.actionConfig = actionConfig;
        this.baseComponentsFactory = new BaseRunMilieuComponentsFactory_1.BaseRunMilieuComponentsFactory(options, actionConfig);
    }
    prepareRunnerDirs() {
        const baseDirs = this.baseComponentsFactory.prepareRunnerDirs();
        return RunnerDirsCollection_1.RunnerDirsCollection.safePrepare(collection => {
            collection.apply(baseDirs.data);
            collection.data.githubHome = this.prepareGithubHomeDir();
            collection.data.fileCommands = this.prepareFileCommandsDir();
            collection.data.githubWorkflow = this.prepareGithubWorkflowDir();
        });
    }
    prepareFiles(fileCommandsDir, githubWorkflowDir) {
        return FakeFilesCollection_1.FakeFilesCollection.safePrepare(collection => {
            if (this.options.fakeFsOptions.data.fakeCommandFiles) {
                collection.createCommandFilesInDir(fileCommandsDir);
            }
            if (this.options.githubContext && this.options.githubContext.data.payload) {
                collection.createEventPayloadFileInDir(this.options.githubContext.data.payload, githubWorkflowDir, `event.json`);
            }
        });
    }
    prepareEnv(fakeFiles, runnerDirs) {
        const envStore = new EnvStore_1.EnvStore(this.options.env.data);
        if (this.options.shouldAddProcessEnv === true) {
            this.baseComponentsFactory.addProcessEnvToEnv(envStore);
        }
        this.baseComponentsFactory.addInputsToEnv(envStore);
        this.baseComponentsFactory.addStateToEnv(envStore);
        this.baseComponentsFactory.addGithubServiceEnvToEnv(envStore);
        this.baseComponentsFactory.addGithubContextToEnv(envStore);
        this.addFilesToEnv(envStore, fakeFiles, runnerDirs);
        this.addTempDirToEnv(envStore);
        this.addWorkspaceDirToEnv(envStore);
        return envStore;
    }
    getVolumes(dirs) {
        return (0, collections_1.mapObject)(dirs.data, (name, dir) => [dir.dirPath, DockerRunMilieuComponentsFactory.DIRS_MOUNTING_POINTS[name]]);
    }
    getFakeFileDirName(name) {
        switch (name) {
            case GithubServiceFileName_1.GithubServiceFileName.EVENT_PATH: return 'githubWorkflow';
            default: return 'fileCommands';
        }
    }
    addFilesToEnv(envStore, fakeFiles, runnerDirs) {
        envStore.unsetFileCommandPaths();
        envStore.apply((0, collections_1.mapToObject)(fakeFiles.files, (name, file) => {
            const dirName = this.getFakeFileDirName(name);
            const dirPath = runnerDirs.data[dirName].dirPath;
            (0, assert_1.default)(path_1.default.dirname(file.filePath) === dirPath, `File ${name} has path = "${file.filePath}" that is not in "${dirPath}" dir`);
            return [
                file.filePathEnvVariable,
                path_1.default.posix.join(DockerRunMilieuComponentsFactory.DIRS_MOUNTING_POINTS[dirName], path_1.default.basename(file.filePath))
            ];
        }));
    }
    addTempDirToEnv(envStore) {
        envStore.apply({ RUNNER_TEMP: DockerRunMilieuComponentsFactory.DIRS_MOUNTING_POINTS.temp });
    }
    addWorkspaceDirToEnv(envStore) {
        envStore.apply({ GITHUB_WORKSPACE: DockerRunMilieuComponentsFactory.DIRS_MOUNTING_POINTS.workspace });
    }
    prepareGithubHomeDir() {
        return FakeRunnerDir_1.FakeRunnerDir.create(this.options.fakeFsOptions.data.tmpRootDir);
    }
    prepareFileCommandsDir() {
        return FakeRunnerDir_1.FakeRunnerDir.create(this.options.fakeFsOptions.data.tmpRootDir);
    }
    prepareGithubWorkflowDir() {
        return FakeRunnerDir_1.FakeRunnerDir.create(this.options.fakeFsOptions.data.tmpRootDir);
    }
}
exports.DockerRunMilieuComponentsFactory = DockerRunMilieuComponentsFactory;
DockerRunMilieuComponentsFactory.DIRS_MOUNTING_POINTS = {
    githubHome: '/github/home',
    temp: '/home/runner/work/_temp',
    workspace: '/github/workspace',
    githubWorkflow: '/github/workflow',
    fileCommands: '/github/file_commands'
};
//# sourceMappingURL=DockerRunMilieuComponentsFactory.js.map