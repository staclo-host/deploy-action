"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsSanitizerStream = void 0;
const stream_1 = require("stream");
const os_1 = __importDefault(require("os"));
const streamUtils_1 = require("../utils/streamUtils");
const stdoutCommands_1 = require("./stdoutCommands");
class CommandsSanitizerStream extends stream_1.Transform {
    constructor() {
        super(...arguments);
        this._unprocessedLine = '';
    }
    _transform(chunk, encoding, callback) {
        chunk = (0, streamUtils_1.chunkToString)(chunk, encoding);
        this._unprocessedLine += chunk;
        // I don't know how GitHub runner separates lines: based on os separator or os-independent
        // So I detect both \r\n and \n separators and replace them with os.EOL
        const lines = this._unprocessedLine.split(/\r?\n/);
        if (lines.length > 1) {
            for (let i = 0; i < lines.length - 1; ++i) {
                this.push(CommandsSanitizerStream.sanitizeLine(lines[i]) + os_1.default.EOL, "utf8");
            }
            this._unprocessedLine = lines[lines.length - 1];
        }
        callback();
    }
    _flush(callback) {
        this.push(CommandsSanitizerStream.sanitizeLine(this._unprocessedLine));
        callback();
    }
    static sanitizeLine(str) {
        return str.replace(stdoutCommands_1.stdoutCmdRegexp, '⦂⦂$1$2⦂⦂');
    }
}
exports.CommandsSanitizerStream = CommandsSanitizerStream;
//# sourceMappingURL=CommandsSanitizerStream.js.map