"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputsCommandsCollector = void 0;
const CommandsStore_1 = require("../runResult/CommandsStore");
const CommandsParsingStream_1 = require("./CommandsParsingStream");
const DeprecatedStdoutCommandWarning_1 = require("../runResult/warnings/DeprecatedStdoutCommandWarning");
const stdoutCommands_1 = require("./stdoutCommands");
/**
 * It's not documented, but GitHub Actions parses commands from both stdout and stderr streams
 */
class OutputsCommandsCollector {
    constructor(parseStdout, parseStderr) {
        this.parseStdout = parseStdout;
        this.parseStderr = parseStderr;
        this.commandsStore = new CommandsStore_1.CommandsStore();
        this.commandsWarnings = new Map();
        const createStream = () => new CommandsParsingStream_1.CommandsParsingStream();
        const addCmdToStore = (cmd) => {
            this.checkDeprecation(cmd);
            this.commandsStore.addStdoutCommand(cmd);
        };
        if (parseStdout) {
            this.stdoutParsingStream = createStream();
            this.stdoutParsingStream.on('data', addCmdToStore);
        }
        if (parseStderr) {
            this.stderrParsingStream = createStream();
            this.stderrParsingStream.on('data', addCmdToStore);
        }
    }
    waitUntilStreamsAreClosed() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stdoutParsingStream) {
                yield this.stdoutParsingStream.waitUntilClosed();
            }
            if (this.stderrParsingStream) {
                yield this.stderrParsingStream.waitUntilClosed();
            }
        });
    }
    get commandWarnings() {
        return [...this.commandsWarnings.values()];
    }
    checkDeprecation(cmd) {
        let msg = undefined;
        switch (cmd.command) {
            case stdoutCommands_1.StdoutCommandName.SAVE_STATE:
            case stdoutCommands_1.StdoutCommandName.SET_OUTPUT: {
                msg = `Deprecated ${cmd.command} command issued. See https://github.blog/changelog/2022-10-11-github-actions-deprecating-save-state-and-set-output-commands/`;
                break;
            }
            case stdoutCommands_1.StdoutCommandName.ADD_PATH:
            case stdoutCommands_1.StdoutCommandName.SET_ENV: {
                msg = `Deprecated ${cmd.command} command issued. See https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/`;
                break;
            }
        }
        if (msg !== undefined && !this.commandsWarnings.has(cmd.command)) {
            this.commandsWarnings.set(cmd.command, new DeprecatedStdoutCommandWarning_1.DeprecatedStdoutCommandWarning(msg, cmd.command));
        }
    }
}
exports.OutputsCommandsCollector = OutputsCommandsCollector;
//# sourceMappingURL=OutputsCommandsCollector.js.map