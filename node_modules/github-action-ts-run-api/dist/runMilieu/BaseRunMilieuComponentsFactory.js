"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRunMilieuComponentsFactory = void 0;
const RunnerDirsCollection_1 = require("../githubServiceFiles/RunnerDirsCollection");
const FakeRunnerDir_1 = require("../githubServiceFiles/runnerDir/FakeRunnerDir");
const ExternalRunnerDir_1 = require("../githubServiceFiles/runnerDir/ExternalRunnerDir");
const FakeFilesCollection_1 = require("../githubServiceFiles/FakeFilesCollection");
const EnvStore_1 = require("../runOptions/EnvStore");
const collections_1 = require("../utils/collections");
const GithubContextStore_1 = require("../runOptions/GithubContextStore");
const GithubServiceEnvStore_1 = require("../runOptions/GithubServiceEnvStore");
class BaseRunMilieuComponentsFactory {
    constructor(options, actionConfig) {
        this.options = options;
        this.actionConfig = actionConfig;
    }
    prepareRunnerDirs() {
        return RunnerDirsCollection_1.RunnerDirsCollection.safePrepare(collection => {
            collection.data.temp = this.prepareTempDir();
            collection.data.workspace = this.prepareWorkspaceDir();
        });
    }
    prepareFiles() {
        return FakeFilesCollection_1.FakeFilesCollection.safePrepare(collection => {
            if (this.options.fakeFsOptions.data.fakeCommandFiles) {
                collection.createCommandFiles();
            }
            if (this.options.githubContext && this.options.githubContext.data.payload) {
                collection.createEventPayloadFile(this.options.githubContext.data.payload);
            }
        });
    }
    prepareEnv(fakeFiles, runnerDirs) {
        const envStore = new EnvStore_1.EnvStore(this.options.env.data);
        this.addProcessEnvToEnv(envStore);
        this.addInputsToEnv(envStore);
        this.addStateToEnv(envStore);
        this.addGithubServiceEnvToEnv(envStore);
        this.addGithubContextToEnv(envStore);
        this.addFilesToEnv(envStore, fakeFiles);
        this.addTempDirToEnv(envStore, runnerDirs.data.temp);
        this.addWorkspaceDirToEnv(envStore, runnerDirs.data.workspace);
        return envStore;
    }
    addProcessEnvToEnv(envStore) {
        if (this.options.shouldAddProcessEnv) {
            envStore.apply(process.env);
        }
    }
    addInputsToEnv(envStore) {
        const inputEnvs = this.actionConfig.getDefaultInputs()
            .apply(this.options.inputs.data)
            .toEnvVariables();
        envStore.apply(inputEnvs);
    }
    addStateToEnv(envStore) {
        envStore.apply(this.options.state.toEnvVariables());
    }
    addGithubServiceEnvToEnv(envStore) {
        let githubServiceEnv = this.options.githubServiceEnv;
        if (this.options.shouldFakeMinimalGithubRunnerEnv) {
            githubServiceEnv = (new GithubServiceEnvStore_1.GithubServiceEnvStore())
                .fakeMinimalRunnerEnv()
                .apply(this.options.githubServiceEnv.data);
        }
        envStore.apply(githubServiceEnv.data);
    }
    addGithubContextToEnv(envStore) {
        var _a;
        const githubContext = this.options.shouldFakeMinimalGithubRunnerEnv
            ? (new GithubContextStore_1.GithubContextStore())
                .fakeMinimalRunnerContext((_a = this.actionConfig.data) === null || _a === void 0 ? void 0 : _a.name)
                .apply(this.options.githubContext.data)
            : this.options.githubContext;
        envStore.apply(githubContext.toEnvVariables());
    }
    addFilesToEnv(envStore, fakeFiles) {
        envStore.unsetFileCommandPaths();
        envStore.apply((0, collections_1.mapToObject)(fakeFiles.files, (name, file) => [file.filePathEnvVariable, file.filePath]));
    }
    addTempDirToEnv(envStore, dir) {
        envStore.apply({ RUNNER_TEMP: dir.dirPath });
    }
    addWorkspaceDirToEnv(envStore, dir) {
        envStore.apply({ GITHUB_WORKSPACE: dir.dirPath });
    }
    prepareWorkspaceDir() {
        return this.options.workspaceDir
            ? new ExternalRunnerDir_1.ExternalRunnerDir(this.options.workspaceDir)
            : FakeRunnerDir_1.FakeRunnerDir.create(this.options.fakeFsOptions.data.tmpRootDir);
    }
    prepareTempDir() {
        return this.options.tempDir
            ? new ExternalRunnerDir_1.ExternalRunnerDir(this.options.tempDir)
            : FakeRunnerDir_1.FakeRunnerDir.create(this.options.fakeFsOptions.data.tmpRootDir);
    }
}
exports.BaseRunMilieuComponentsFactory = BaseRunMilieuComponentsFactory;
//# sourceMappingURL=BaseRunMilieuComponentsFactory.js.map