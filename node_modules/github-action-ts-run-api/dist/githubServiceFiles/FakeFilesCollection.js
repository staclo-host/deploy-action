"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeFilesCollection = void 0;
const GithubServiceFileName_1 = require("./GithubServiceFileName");
const FakeFile_1 = require("./FakeFile");
const readFileCommands_1 = require("./readFileCommands");
const fs_extra_1 = __importDefault(require("fs-extra"));
class FakeFilesCollection {
    constructor() {
        this.files = new Map();
    }
    /**
     * Create collection and modify it in a callback. Clean up any added files in case of error
     */
    static safePrepare(callback) {
        const collection = new FakeFilesCollection();
        try {
            callback(collection);
            return collection;
        }
        catch (err) {
            collection.cleanUp();
            throw err;
        }
    }
    createCommandFiles(tempDirPath) {
        return this.createCommandFilesImpl(undefined, tempDirPath);
    }
    createCommandFilesInDir(dirPath) {
        return this.createCommandFilesImpl(dirPath, undefined);
    }
    createCommandFilesImpl(dirPath, tempDirPath) {
        const commandFileNames = (0, GithubServiceFileName_1.getFileCommandNames)();
        const existingFiles = commandFileNames.filter(name => this.files.has(name));
        if (existingFiles.length > 0) {
            throw new Error(`Command files ${existingFiles.join(', ')} already exist`);
        }
        commandFileNames.forEach(name => this.files.set(name, dirPath
            ? FakeFile_1.FakeFile.createInDir(name, dirPath, name)
            : FakeFile_1.FakeFile.create(name, tempDirPath)));
        return this;
    }
    createEventPayloadFile(payload, tempDirPath, fileName) {
        return this.createEventPayloadFileImpl(payload, undefined, tempDirPath, fileName);
    }
    createEventPayloadFileInDir(payload, dirPath, fileName) {
        return this.createEventPayloadFileImpl(payload, dirPath, undefined, fileName);
    }
    createEventPayloadFileImpl(payload, dirPath, tempDirPath, fileName) {
        if (this.files.has(GithubServiceFileName_1.GithubServiceFileName.EVENT_PATH)) {
            throw new Error(`Event payload file already exists`);
        }
        const file = dirPath
            ? FakeFile_1.FakeFile.createInDir(GithubServiceFileName_1.GithubServiceFileName.EVENT_PATH, dirPath, fileName)
            : FakeFile_1.FakeFile.create(GithubServiceFileName_1.GithubServiceFileName.EVENT_PATH, tempDirPath);
        this.files.set(GithubServiceFileName_1.GithubServiceFileName.EVENT_PATH, file);
        fs_extra_1.default.writeFileSync(file.filePath, JSON.stringify(payload));
        return this;
    }
    readFileCommands(eol) {
        const result = {
            outputs: {},
            savedState: {},
            exportedVars: {},
            addedPaths: []
        };
        this.files.forEach((file, cmdName) => {
            switch (cmdName) {
                case GithubServiceFileName_1.GithubServiceFileName.ENV:
                    result.exportedVars = (0, readFileCommands_1.readKvPairsFromFileCommand)(file.filePath, eol);
                    break;
                case GithubServiceFileName_1.GithubServiceFileName.PATH:
                    result.addedPaths = (0, readFileCommands_1.readValuesFromFileCommand)(file.filePath, eol);
                    break;
                case GithubServiceFileName_1.GithubServiceFileName.STATE:
                    result.savedState = (0, readFileCommands_1.readKvPairsFromFileCommand)(file.filePath, eol);
                    break;
                case GithubServiceFileName_1.GithubServiceFileName.OUTPUT:
                    result.outputs = (0, readFileCommands_1.readKvPairsFromFileCommand)(file.filePath, eol);
                    break;
            }
        });
        return result;
    }
    cleanUp() {
        this.files.forEach(file => file.delete());
    }
}
exports.FakeFilesCollection = FakeFilesCollection;
//# sourceMappingURL=FakeFilesCollection.js.map