"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readValuesFromFileCommand = exports.readKvPairsFromFileCommand = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const assert_1 = __importDefault(require("assert"));
const commandsEscaping_1 = require("../utils/commandsEscaping");
function readFileCommandLines(filePath, eol) {
    if (!fs_extra_1.default.existsSync(filePath)) {
        return [];
    }
    const lines = fs_extra_1.default.readFileSync(filePath).toString('utf-8').split(eol);
    if (lines[lines.length - 1].length === 0) {
        lines.pop();
    }
    return lines;
}
function readKvPairsFromFileCommand(filePath, eol) {
    let ExpectedToken;
    (function (ExpectedToken) {
        ExpectedToken[ExpectedToken["NAME_OR_ONE_LINER"] = 0] = "NAME_OR_ONE_LINER";
        ExpectedToken[ExpectedToken["VALUE"] = 1] = "VALUE";
        ExpectedToken[ExpectedToken["VALUE_LINE_OR_FINISH_DELIMITER"] = 2] = "VALUE_LINE_OR_FINISH_DELIMITER";
    })(ExpectedToken || (ExpectedToken = {}));
    const lines = readFileCommandLines(filePath, eol);
    const kvPairs = {};
    let expectedToken = ExpectedToken.NAME_OR_ONE_LINER;
    let name = undefined;
    let delimiter = undefined;
    let value = undefined;
    for (let line of lines) {
        switch (expectedToken) {
            case ExpectedToken.NAME_OR_ONE_LINER:
                const nameAndDelimiter = line.split('<<');
                if (nameAndDelimiter.length == 2) {
                    [name, delimiter] = nameAndDelimiter;
                    expectedToken = ExpectedToken.VALUE;
                    break;
                }
                const nameAndValue = line.split('=');
                if (nameAndValue.length == 2) {
                    kvPairs[nameAndValue[0]] = nameAndValue[1];
                    name = undefined;
                    value = undefined;
                    expectedToken = ExpectedToken.NAME_OR_ONE_LINER;
                    break;
                }
                console.warn(`Error parsing ${filePath} commands file. ` +
                    'Expected line is either in VAR=VAL format or VAR<<delimiter. Read line');
                console.warn(line);
                break;
            case ExpectedToken.VALUE:
                value = (0, commandsEscaping_1.unescapeCommandValue)(line);
                expectedToken = ExpectedToken.VALUE_LINE_OR_FINISH_DELIMITER;
                break;
            case ExpectedToken.VALUE_LINE_OR_FINISH_DELIMITER:
                (0, assert_1.default)(delimiter !== undefined);
                if (line === delimiter) {
                    (0, assert_1.default)(name !== undefined && value !== undefined);
                    kvPairs[name] = value;
                    expectedToken = ExpectedToken.NAME_OR_ONE_LINER;
                    name = undefined;
                    value = undefined;
                }
                else {
                    (0, assert_1.default)(value !== undefined);
                    value += eol + line;
                }
        }
    }
    return kvPairs;
}
exports.readKvPairsFromFileCommand = readKvPairsFromFileCommand;
function readValuesFromFileCommand(filePath, eol) {
    return readFileCommandLines(filePath, eol).map(commandsEscaping_1.unescapeCommandValue);
}
exports.readValuesFromFileCommand = readValuesFromFileCommand;
//# sourceMappingURL=readFileCommands.js.map